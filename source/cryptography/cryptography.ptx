<?xml version="1.0" encoding="UTF-8" ?>
<!-- Generated by Pandoc using pretext.lua -->
<chapter xml:id="ch-cryptography" xmlns:xi="http://www.w3.org/2001/XInclude">
	<title>Secret Codes &amp; the NSA</title>
	<xi:include href="./sec_objectives.ptx" />

	<subsection xml:id="preliminary-activity">
		<title>Preliminary Activity</title>

			<p>
				There are many exercises below in which students are asked to analyze plaintext or ciphertext where said text is not specified. These texts may be provided the instructor based on the cryptographic methods described below. This flexibility is emphasized in order to allow customization of the specific texts students will play with, including customizing ciphertexts to a college or university’s context.
			</p>

			<p>
				It is useful to establish some cryptographic terminology which we will use for the remainder of this text. To that end, consider the definitions below:
			</p>

			<p>
				<em>Cryptography</em> (from Greek <em>kryptos-</em>, meaning <q>hidden</q>) is secret communication by hiding the meaning of a message, not its existence. The process of hiding the meaning of a message is called <em>encryption.</em> The recipient of the message has to <em>decrypt</em> or <em>decipher</em> the message in order to read it.
			</p>

			<p>
				Often the method of encryption relies on a <em>key</em>, some special number(s) or word(s) that only the sender and recipient know. <em>Cryptanalysis</em> is the study of cryptographic algorithms with the intent of recovering secret messages <em>without</em> knowing the secret key.
			</p>

			<p>
				There are two basic tools that can be used in encryption algorithms: <em>transposition</em> (rearranging the characters) and <em>substitution</em> (replacing characters with other characters). The emphasis of these notes will be on substitution ciphers.
			</p>

			<p>
				A <em>(substitution)</em> <em>cipher</em> is an algorithm for encrypting a message into apparently unintelligible <em></em> text<em>.</em> Each cipher may be viewed as a function <me>f:\mathcal{P}\to\mathcal{C}</me> where <m>\mathcal{P}</m> is the space of <em>plaintext</em>, or readable text in a given alphabet (here the English alphabet consisting of the <m>26</m> lowercase English letters will be used unless specified otherwise) and <m>\mathcal{C}</m> is the space of <em>ciphertext</em> or encrypted text (here the uppercase <m>26</m>-letter English alphabet unless otherwise specified). We also identify each letter in <m>\mathcal{P}</m> and <m>\mathcal{C}</m>, in order, with an element of <m>\mathbb{Z}/26\mathbb{Z}</m> (so that <m>a\leftrightarrow0,b\leftrightarrow1</m>, etc.). It will be clear from context which representation of <m>\mathcal{P}</m> and <m>\mathcal{C}</m> we are using. If <m>f</m> is injective (and hence, since here <m>\mathcal{P}</m> and <m>\mathcal{C}</m> are finite, bijective), we say it is a <em>monoalphabetic (substitution) cipher</em>.
			</p>

			<p>
				The use of uppercase in the ciphertext and lowercase in the plaintext is a cryptographic convention designed to distinguish the two types of text, especially in partially-deciphered messages; we will often ignore the distinction and say, for example, <q><m>f(p)=p+3</m> is the shift cipher with shift <m>+3</m></q> where lowercase <m>p\in\mathcal{P},c\in\mathcal{C}</m> denote individual letters. We will commonly refer to a particular <m>p\in\mathcal{P}</m> which we will call simply <em>the plaintext</em> and its image <m>c:=f(p)\in\mathcal{C}</m> (<em>the ciphertext</em>). Notably, for courses without mathematical prerequisites such as that taught by the other using the flow of concepts below, the spaces and notation <m>\mathcal{P}</m> and <m>\mathcal{C}</m> are hidden, and ciphers are analyzed by analyzing particular <m>p</m> and <m>f(p)</m>, as well as determining <m>f^{-1}(c)</m> given particular <m>c\in\mathcal{C}</m>.
			</p>

<!-- div attr= class="act"-->
			<p>
				<term> 1</term>.  <em>One may begin by simply giving students various encrypted messages to decode along with a handful of hints. Ask students to work in groups, with one member of each group of 3-4 students serving as the facilitator, the recorder, and the reporter (sharing their work with the class), respectively. For instructors following the order of topics below, it is important that at least one message be a <em>shift cipher</em>, a cipher of form <m>f(p)=p+k\mod26</m> for some <m>k\in\mathbb{Z}/26\mathbb{Z}</m>. In order for students to be able to systematically decrypt a shift cipher, the message should either be fairly long (students can split the message into pieces when decrypting it) or otherwise rigged so that plaintext <sq>e</sq> is one of the top three most common letters in the plaintext.</em>
			</p>

			<p>
				<em>It is recommended to give students two other messages as well. At this stage students are often not prepared for ciphers <m>f</m> which are not bijective, so one may use, for example, a <em>keyword cipher</em> <me>f=\begin{pmatrix}a &amp; b &amp; c &amp; d &amp; e &amp; f &amp; g &amp; h &amp; \dots &amp; z \\
                 K &amp; E &amp; Y &amp; W &amp; O &amp; R &amp; D &amp; A &amp; \dots &amp; Z 
\end{pmatrix}</me> where the <em>keyword</em> is a chosen English word and the plaintext, again, is long enough or otherwise rigged so that the plaintext letters occur with similar relative frequencies to those of English as a whole. Note the following features of the keyword cipher: first the keyword is spelled out under the first <m>n</m> letters of the plaintext alphabet, where <m>n</m> is the number of distinct letters in the keyword. Then the alphabet is spelled out in order, except that when a letter has already been written as part of the keyword, it is skipped and we move onto the next letter of the alphabet.</em>
			</p>

			<p>
				<em>The above keyword cipher illustrates a <em>cipher alphabet</em> in function form: a representation of the ordered pair <m>(\mathcal{P},f(\mathcal{P}))</m> for a given cipher <m>f</m>. Of course, any other representation of <m>(\mathcal{P},f(\mathcal{P}))</m>, such as a table of values, will do (and tables of values are commonly used to represent cipher alphabets). Students often decrypt such a message without identifying the keyword, but it is fruitful to point out that identifying a pattern will assist in the decryption process at this stage.</em>
			</p>

			<p>
				<em>Finally, it is recommended to assign one unsolved cipher such as that used in Part <m>4</m> of the Kryptos sculpture <xref ref="bauerJamesSanbornKryptos2016"></xref>. Pass on (unattributed) to the students the hints that artist Jim Sanborn gave: the ciphertext letters NYPVTT decrypt to BERLIN, and the word immediately following BERLIN is CLOCK. Then, give students time in groups to attempt to solve all three ciphers. Usually many students solve the shift cipher, a good handful (with my assistance) solve the keyword cipher, and generally these students move onto Kryptos, notice it’s not monoalphabetic since (by the hints) <m>i,n\mapsto T</m>, get frustrated, wonder about spacing, and come to a loss. At this stage one may tell them something like, <q>this is an unsolved cipher known as Kryptos Part <m>4</m>; solve it and you’ll be famous!</q></em>
			</p>

			<p>
				<em>Follow up by letting them know that we are not trying to be cruel, then ask them why we would give them an unsolved code. Based on our conversation, one may follow up with statements like, <q>What do you think mathematicians spend most of their time doing? How do you define <q>success</q> when working on an unsolved problem?</q> We emphasize that making sense of a problem, increasing their depth of understanding (what methods DON’T work?), describing their process of engagement, and even failing are all completely normal aspects of doing mathematics. Even problems that are solved often took years or even millennia to solve; therefore, there is no shame or cause for alarm if they don’t understand something immediately. This helps ground students as we move onto more and more abstract and difficult mathematics.</em>
			</p><!--</div attr= class="act">-->

			<p>
				Now, ask students what strategies they used to decrypt the messages above. For the first message, students may use <em>brute force,</em> simply trying various shifts until one works. However, a more interesting strategy involves counting which ciphertext letter is the most frequent and guessing that letter corresponds to plaintext <sq>e</sq>.
			</p>

		</subsection>

		<subsection xml:id="the-caesarshift-cipher">
			<title>The Caesar/shift cipher</title>

			<p>
				The <em>Caesar cipher</em> is an example of a <em>monoalphabetic substitution cipher</em>, in which every character is replaced by some other character. It is the earliest known example of a substitution cipher and, according to the Roman historian Suetonius, was used by Julius Caesar himself. It is currently understood as encrypting messages by shifting every letter forward in the alphabet by <m>3</m>; that is, as the function <m>f(p)=p+3\mod26</m>. More generally, a <em>shift cipher</em> may shift every letter forward by any amount.
			</p>

			<p>
				It is easy to generate example shift ciphertext and have students decrypt this ciphertext. Prompt them to continually investigate the methods they use to cryptanalyze shift ciphers: does it involve brute force? Counting the number of occurrences of each letter and comparing to English letter frequencies, then guessing the most common ciphertext letter corresponds to <m>e</m>? Spotting patterns between adjacent letters? There is no <q>wrong</q> way, but it is the goal of cryptographers to find a general method for decrypting a given family of cipher no matter the particular message or peculiarities of the cipher; therefore, we want to move students’ thinking toward counting letter frequencies as a method of cryptanalyzing any monoalphabetic substitution cipher.
			</p>

			<p>
				Inform students that there is a faster way to decrypt shift ciphers than saying the alphabet backwards in their heads. Ask them to try decrypting a message that was encrypted with a very large forward shift such as <m>+25</m>. How would they do it? Likely by shifting each letter <em>forwards</em> by <m>1</m> to obtain the plaintext message. This means that in the English alphabet, <m>0=25+1=26</m>, and now you can introduce modular arithmetic (working with modulus <m>26</m> for the foreseeable future). It’s beneficial to provide students with a <em>letter-to-number correspondence sheet</em>, which numbers English letters in increasing order starting with <m>a=0</m>.
			</p>

<!-- div attr= class="act"-->
			<p>
				<term> 2</term>.  <em>Have students decrypt a message (long enough or rigged so that its letter frequencies are close to those in English in general) that was encrypted using each of the following:</em>
			</p>

			<p><ol>
				<li>
							<p>
				<em>A Caesar cipher <m>c\equiv p+3\mod26</m>.</em>
			</p>
				</li>

				<li>
							<p>
				<em>A shift cipher with a shift other than <m>3</m> (without telling students the shift).</em>
			</p>
				</li>

				<li>
							<p>
				<em>A shift cipher with a shift greater than <m>26</m> (without telling students the shift).</em>
			</p>
				</li>

				<li>
							<p>
				<em>How many different shift ciphers are there in the English alphabet? In other words, how hard is it to cryptanalyze the shift cipher by brute force?</em>
			</p>
				</li>

			</ol></p><!--</div attr= class="act">-->

			<p>
				The usefulness of the clock metaphor for introducing modular arithmetic cannot be overstated: we are thinking of the alphabet as a clock with <m>26</m> numbers on it, going from <m>0</m> on the top to <m>25</m>. Can students determine various times on this clock? Up until this point, students were not likely to fully understand our definition of a cipher as a function modulo <m>26</m>, but now they can. The following activity is one I’ve used to help students learn basic modular arithmetic without any prerequisites:
			</p>

<!-- div attr= class="act"-->
			<p>
				<term> 3</term>. 
			</p>

			<p><ol>
				<li>
							<p>
				<em>Reduce several numbers modulo <m>26</m>, including numbers much larger than <m>26</m>, using various notions of <q>congruence modulo <m>26</m></q> (e.g. <m>a\equiv b\mod26</m> if <m>a</m>:00 and <m>b</m>:00 are the same time on a <m>26</m>-hour clock, <m>a</m> and <m>b</m> have the same remainder upon division by <m>26</m>, <m>26\mid (a-b)</m>, subtracting a multiple of <m>26</m> from <m>b</m> yields <m>a</m>).</em>
			</p>
				</li>

				<li>
							<p>
				<em>Create addition and multiplication tables modulo 5 and modulo 14. What patterns do students notice? What do they wonder about these tables?</em>
			</p>
				</li>

			</ol></p><!--</div attr= class="act">-->

		</subsection>

		<subsection xml:id="frequency-analysis">
			<title>Frequency analysis</title>

			<p>
				To determine the amount of the shift for an unknown shift cipher, the 9th century Iraqi Arab polymath Abu Yūsuf Ya‘qūb ibn ’Isḥāq aṣ-Ṣabbāḥ al-Kindı̄, in order to better understand what he saw as God’s messages in the Qu’ran, developed a technique that later became known as <em>frequency analysis</em>. The following passage from his <em>Manuscript on Deciphering Crptographic Messages</em> describes this technique:
			</p>

			<blockquote>
							<p>
				One way to solve an encrypted message, if we know its language, is to find a different plaintext of the same language long enough to fill one sheet or so, and then we count the occurrences of each letter. We call the most frequently occurring letter the ‘first’, the next most occurring letter the ‘second’, the following most occurring the ‘third’, and so on, until we account for all the different letters in the plaintext sample.
			</p>

			<p>
				Then we look at the cipher text we want to solve, and we also classify its symbols. We find the most occurring symbol and change it to the form of the ‘first’ letter of the plaintext sample, the next most common symbol is changed to the form of the ‘second’ letter, and so on, until we account for all symbols of the cryptogram we want to solve.
			</p>
			</blockquote>

			<p>
				In this portion of the project, have students develop their own <q>frequency analysis muscle</q> and hone it into a mental algorithm for cryptanalyzing shift ciphers.
			</p>

<!-- div attr= class="act"-->
			<p>
				<term> 4</term>.  <em>The mnemonic <q>ETAOIN SHRDLU</q> is useful for remembering the relative frequencies of the twelve most common English letters in decreasing order of frequency, although the mnemonic does not reflect all written English and changes with the living language.</em>
			</p>

			<p><ol>
				<li>
							<p>
				<em>(Optional for coding-focused courses) Use the step-by-step module at <xref ref="inceResourcesFirstYearCollege2022"></xref> entitled <q>Frequency Analysis</q> to write a Python frequency analysis tool. Then input several English texts of at least, say, twenty pages, and verify that most of the most frequent twelve letters are in the list ETAOIN SHRDLU.</em>
			</p>
				</li>

				<li>
							<p>
				<em>Take three or four English texts of at least a couple of pages in length (books in the public domain, found online, are a good source of plaintext here). Encrypt these using shifts chosen however you like, then have students use their Python program, or one of the many available frequency analysis applets online, to determine the shifts used to encrypt each message. For additional practice, have them decrypt the first sentence and verify their guessed shift is correct. <em>Note</em>: some texts, especially shorter ones, will require students to guess multiple shifts and test each to see which gives legible plaintext, which verifies that their guess was correct.</em>
			</p>
				</li>

			</ol></p><!--</div attr= class="act">-->

		</subsection>

		<subsection xml:id="affine-ciphers">
			<title>Affine ciphers</title>

			<p>
				At this stage, you may introduce <em>affine ciphers</em>, a natural generalization of shift ciphers. We’ve described the shift cipher as a function <m>f(p)\equiv p+k\mod26</m>. Note that this is simply a linear function with slope <m>1</m> and <m>y</m>-intercept <m>k</m>. But there is no requirement that ciphers stick to a slope of <m>1</m>; the <em>affine cipher</em> first <em>multiplies</em> the plaintext letter by a certain amount <m>m</m>, then adds a constant amount <m>k</m>. Its equation is 
				<md>
					<mrow number="yes" xml:id="KI-eq-affine-cipher-system">c:=f(p)\equiv mp+k\mod26.</mrow> 
				</md>
				Here <m>m</m> is called the <em>multiplicative key</em> and <m>k</m> the <em>additive key</em>. (We do not call these <q>linear ciphers</q> to avoid confusion with the notion of <q>linear</q> students may see in the future when studying linear transformations and homomorphisms.)
			</p>

<!-- div attr= class="act"-->
			<p>
				<term> 5</term>. 
			</p>

			<p><ol>
				<li>
							<p>
				<em>Have students create two or three plaintext messages and pair each message with any value of <m>k</m> and a value of <m>m</m> such that <m>\gcd(m,26)=1</m>. Then encrypt each message using the affine cipher with that multiplicative and additive key.</em>
			</p>
				</li>

				<li>
							<p>
				<em>Pass your resulting ciphertexts clockwise in your group without sharing the values of <m>m</m> and <m>k</m>. What are your thoughts as you attempt to decrypt this ciphertext? (Note that students will likely be unable to decrypt affine ciphertext at this stage, but the resulting considerations may lead them down a fruitful path. We will discuss an algorithm for decrypting affine ciphers in the following section.)</em>
			</p>
				</li>

			</ol></p><!--</div attr= class="act">-->

		</subsection>

		<subsection xml:id="onramp-to-number-theory">
			<title>Onramp to number theory</title>

			<p>
				At this stage, students are ready to learn the material in a standard integer division and modular arithmetic unit, in the order you wish to present it for your context. For example, the material of Chapters <m>2</m> through <m>8</m> of <xref ref="crismanNumberTheoryContext2021"></xref>, from integer division and Diophantine equations to the so-called <q>Chinese</q> (in particular, Sun-tzu) remainder theorem and the theory of cyclic groups, are all motivated by the theory of affine ciphers and can be covered at this stage. We highly recommend calling back to cryptography whenever possible; the following section is an overview of one possible order in which various number-theoretic results can be motivated by the theory of affine ciphers.
			</p>

			<p>
				Following the presentation of shift ciphers above, students may then practice encrypting and decrypting affine ciphers with known multiplicative and additive keys. Prompt them to consider how they would cryptanalyze an affine cipher. After using frequency analysis, they may determine which ciphertext letter corresponds to <m>e</m>, but this is not enough since we need to solve for two unknowns, <m>m</m> and <m>k</m>. So students may realize we need to find two letter pairs of the form <m>(p,c)</m> where <m>c=f(p)</m> and set up a <em>system of congruences <me>\begin{aligned}
c_{1} &amp; \equiv m\cdot p_{1}+k\nonumber \\
c_{2} &amp; \equiv m\cdot p_{2}+k\mod26.\label{KI-eq:affine-cipher-system}
\end{aligned}</me></em>
			</p>

			<p>
				Students may remember how they solved systems of equations in high school. It is recommended to encourage them to use elimination, not substitution, in preparation for future linear algebra classes down the road.
			</p>

			<p>
				A fruitful area of inquiry at this point is to prompt students how, once they obtain a single congruence of the form <me>c_{2}-c_{1}\equiv m(p_{2}-p_{1})\mod26,</me> they might solve for <m>m</m>. Usually students think they can simply <q>divide by <m>p_{2}-p_{1}</m>,</q> so it takes some prompting (<q>what if <m>p_{2}-p_{1}=13</m>?</q>) for them to realize this is not always possible modulo <m>n</m>. This is a natural spot to introduce the idea of inverses modulo <m>26</m>, and more generally modulo <m>n</m>. We’ll start with some more basic facts and build up to solving systems of congruences.
			</p>

			<p>
				The <em>multiplicative inverse <m>a^{-1}</m> of <m>a\mod n</m></em> is the number <m>a^{-1}</m> so that <m>aa^{-1}\equiv1\mod n</m>, if such an <m>a^{-1}</m> exists. Recall that a number is <em>prime</em> if the only integers that divide it are <m>1</m> and itself. <em>Composite numbers</em> are integers greater than one that are not prime. Every positive whole number has a unique <em>prime factorization</em>, i.e. a way to write it as a product of prime numbers. This fact is called the <em>Fundamental Theorem of Arithmetic.</em>
			</p>

<!-- div attr= class="act"-->
			<p>
				<term> 6</term>.  <em>Have students attempt to encrypt given messages with the affine cipher using various multiplicative and additive keys. To illustrate the relevant idea that <m>c\equiv mp+k\mod n</m> is monoalphabetic if and only if <m>\gcd(m,n)=1</m>, have students use at least one <m>m</m> relatively prime to <m>26</m> and one <m>m</m> that is not (for example <m>m=13</m>, which makes very clear to students that the resulting affine cipher is not monoalphabetic and near-impossible to decrypt even by someone who knows the key).</em>
			</p>

			<p>
				<em>Ask students: from the work you just did, what multiplicative keys do you think <q>work</q> for affine ciphers? What is the <q>problem</q> with the keys that don’t work? Even if they don’t have a complete sense of the issue, have them explain their hypothesis. Prompt students to make multiplication tables modulo <m>n</m> for some reasonably small composite <m>n</m>; ask them to compare what happens in rows which are relatively prime to <m>n</m> versus rows that aren’t. How might this connect to the issue with the affine cipher <m>c\equiv13p+k\mod26</m>? What patterns do they notice or wonder about?</em>
			</p><!--</div attr= class="act">-->

			<p>
				Hopefully students will realize that there are significant problems with an affine cipher where <m>m\mid26</m>!
			</p>

<!-- div attr= class="act"-->
			<p>
				<term> 9</term>. 
			</p>

			<p><ol>
				<li>
							<p>
				<em>At this point, it is useful for students to make themselves a <q>cheat sheet</q> which tells them the multiplicative inverse of any number mod 26, if it exists. (My expectation is not that they memorize such a list, though more power to them if they’d like to!) At this point, the most likely strategy students will use to find <m>m^{-1}\mod26</m> is trial and error: multiplying each <m>m</m> by various integers mod <m>26</m> until they end up with <m>1\mod26</m>. The number they multiplied by to get <m>1</m> is their <m>m^{-1}</m>, if such a number exists. Ask: what relationship between <m>m</m> and the modulus <m>26</m> predicts whether <m>m^{-1}</m> exists?</em>
			</p>
				</li>

				<li>
							<p>
				<em>In an introduction to proof or number theory class, this would be an excellent time to prompt students to prove that <m>m^{-1}</m> exists modulo <m>n</m> if and only if <m>\gcd(m,n)=1</m>. Prompt them to think about their multiplication tables and the fact that every integer modulo <m>n</m> appears in the <m>m</m>th row precisely when <m>m</m> and <m>n</m> are relatively prime. In fact, students can prove that</em>
			</p>


				<proposition xml:id="KI-prop-gcd-m-n-divides-mk">
					<statement>
						<p>
							If <m>m</m> is a whole number between <m>0</m> and <m>n-1</m>, then <m>\gcd(m,n)</m> 
							divides any number that’s congruent to <m>m\mod n</m>.
						</p>
					</statement>
				</proposition>


			<p>
				<em>One prompt to lead students toward the general proof is the following specific example: assume some number <m>x</m> is congruent to <m>m=4\mod12</m>. Then <m>x/12=yR4</m> (here <m>R</m> denotes <q>remainder</q> in language that should be familiar to students), where <m>y</m> is some whole number. So <m>x</m> is some multiple of <m>12</m> plus <m>4</m>; we can write <m>x=12y+4</m>, where <m>y</m> is some whole number. Now, <m>\gcd(4,12)=4</m> and <m>x=4(3y+1)</m> is divisible by <m>4</m>.</em>
			</p>
				</li>

				<li>
							<p>
				<em>At this point, students have the cheat sheet and tools necessary to decrypt affine ciphers with known key. Have them try decrypting some example ciphertext under various affine ciphers. Naturally, students may at first be most comfortable only doing arithmetic modulo <m>26</m>, but it takes surprisingly little in my experience to prompt them to consider other moduli. Students may try decrypting affine ciphers in different alphabets at this stage: for example, decrypt <m>c\equiv7p\mod29</m> using the lowercase English alphabet with !?, appended. We need to multiply both sides by some number <m>x</m> so that <m>7x\equiv1\mod29</m>. How do we systematically find <m>x</m>? This is a great time for an optional detour into the extended Euclidean algorithm; students without much previous college-level math experience often find this difficult, so it may be skipped without losing the thread of this activity.</em>
			</p>
				</li>

				<li>
							<p>
				<em>Students in a proof-based course may now attempt to prove the following corollary of Proposition <xref ref="KI-prop-gcd-m-n-divides-mk" />.</em>
			</p>

<!-- div attr= class="cor"-->
			<p>
				<em><term> 8</term>.  <em>If <m>\gcd(m,n)\neq1</m>, then no multiple of <m>m</m> is congruent to <m>1\mod n</m>. In other words, we can’t get every number in row <m>m</m> of the <m>\mod n</m> multiplication table, and <em><m>m</m></em> does not have a multiplicative inverse <em><m>\mod n</m>.</em> In fact, the following are equivalent for any whole numbers <m>m,n</m>:</em></em>
			</p>

			<p><ol>
				<li>
							<p>
				<em><em><m>\gcd(m,n)=1</m>.</em></em>
			</p>
				</li>

				<li>
							<p>
				<em><em>any affine cipher with multiplicative key <m>m\mod n</m> is decryptable by the intended recipient.</em></em>
			</p>
				</li>

				<li>
							<p>
				<em><em>every number between <m>0</m> and <m>n-1</m> is a multiple of <m>m\mod n</m>.</em></em>
			</p>
				</li>

				<li>
							<p>
				<em><em><m>m</m> has a multiplicative inverse <m>m^{-1}\mod n</m>.</em></em>
			</p>
				</li>

			</ol></p><!--</div attr= class="cor">-->

			<p>
				<em>An example that may lead students toward part of the proof: consider the affine cipher <m>c\equiv13p\mod26</m>. Note that <m>\gcd(13,26)=13</m>. Any plaintext letter that we plug in will spit out some multiple of <m>13</m>. Reduced mod <m>26</m>, these multiples of <m>13</m> all become either <m>13</m> or <m>0</m>. And <m>\gcd(13,26)=13</m> divides both <m>13</m> and <m>0</m> evenly. Since no multiple of <m>13</m> can be congruent to <m>1\mod26</m>, <m>13</m> does not have a multiplicative inverse modulo <m>26</m>.</em>
			</p>
				</li>

				<li>
							<p>
				<em>Now, prompt students to consider how important it is before decrypting an affine cipher to verify that <m>\gcd(m,n)=1</m>. Given a cipher like <m>c\equiv137p+538\mod341319</m>, how could students determine whether the cipher was monoalphabetic, and hence whether our techniques will decrypt it?</em>
			</p>
				</li>

				<li>
							<p>
				<em>Computers can only understand numbers (which are written in <m>0</m>s and <m>1</m>s), not letters. The computer language ASCII represents all commonly-used written characters as numbers between <m>1</m> and <m>256</m>. Do you think we can encrypt ASCII messages using the affine cipher <m>C\equiv8P\mod256</m>? Why or why not? What multiplicative keys can be used in a monoalphabetic, affine ASCII cipher?</em>
			</p>
				</li>

			</ol></p><!--</div attr= class="act">-->

			<p>
				We now may introduce the Euclidean algorithm as a powerful (and programmable) tool for finding greatest common divisors. A recommended way of introducing the Euclidean algorithm, as in much of these notes, is to start with an example.
			</p>

<!-- div attr= class="act"-->
			<p>
				<term> 10</term>. 
			</p>

			<p><ol>
				<li>
							<p>
				<em>Suppose we want to find the greatest common divisor of, say, <m>261</m> and <m>231</m>. Have students recall (perhaps by verifying a specific example) that, if a number divides both <m>261</m> and <m>231</m>, then it divides <m>261-231=30</m> as well. Similarly, if a number divides both <m>231</m> and <m>30</m> (as it must if it divides <m>261</m> and <m>231</m>), then it divides <m>231-30=201</m>, and <m>201-30=171</m>, and<m>\dots231-30(7)=21</m>. Therefore, <m>\gcd(261,231)=\gcd(231,30)=\gcd(30,21)=\dots</m>. Hence, compute <m>\gcd(261,231)</m> and verify it using a method more familiar to you, such as factor trees.</em>
			</p>
				</li>

				<li>
							<p>
				<em>Prove that the Euclidean algorithm <q>works</q> in general to compute <m>\gcd(m,n)</m> for any <m>m,n\in\mathbb{Z}</m>.</em>
			</p>
				</li>

				<li>
							<p>
				<em>Use the Euclidean algorithm to compute the gcds of two or three pairs of numbers. It may benefit students to make the first pair of numbers relatively small and one of the pairs relatively large such that the pair of large numbers has a quick Euclidean algorithm solution which is nonobvious using the method of factor trees. For example, one may use any pair of numbers of the form <m>(n,kn+1)</m> for some <m>n,k\in\mathbb{N}</m>.</em>
			</p>
				</li>

				<li>
							<p>
				<em>Unicode is an updated version of ASCII. Unicode gives a way of encoding information on a computer with <m>1,114,112</m> possible numbers. Only about <m>10\%</m> of them are currently in use; say there are <m>111,411</m> Unicode numbers in use. Does the affine cipher <m>C\equiv103,011P+34,423\mod111,411</m> encrypt Unicode characters monoalphabetically?</em>
			</p>
				</li>

			</ol></p><!--</div attr= class="act">-->

			<p>
				To motivate solving systems of linear congruences, we may use the cryptanalysis of affine ciphers. As in (<xref ref="KI-eq-affine-cipher-system" />) above, systems of linear congruences arise naturally after guessing two plaintext-ciphertext pairs in an affine cipher. Solving the system is necessary to determine the multiplicative and additive keys of the affine cipher, hence to decrypt it. The dangerous thing for students at this point is to make the <q>wrong</q> guess and end up trying to solve a congruence of the form <m>am\equiv b\mod26</m> where <m>\gcd(a,26)\neq1</m>. <em></em> This is an excellent time to discuss the general theory of solving linear congruences, and if you wish even generalize to polynomial, factorial, and other more general congruences. At any rate, students may now use the following algorithm to cryptanalyze any monoalphabetic affine cipher:
			</p>

			<p><ol>
				<li>
							<p>
				Form a system of linear congruences to solve for <m>m</m>, the multiplicative constant, and <m>k</m>, the additive constant.
			</p>
				</li>

				<li>
							<p>
				Simplify the system of congruences by substitution, elimination, or addition/subtraction of congruences.
			</p>
				</li>

				<li>
							<p>
				Find the solution of the resulting congruence using trial and error or the extended Euclidean algorithm.
			</p>
				</li>

				<li>
							<p>
				Use <m>m</m> and <m>k</m> to decrypt the ciphertext using the formula <m>p=m^{-1}(c-k)</m> mod <m>26</m>.
			</p>
				</li>

			</ol></p>

			<p>
				To accomplish step <m>1</m>, students must guess two plaintext-ciphertext pairs, and to avoid insoluble congruences, it suffices to always guess the ciphertext corresponding to plaintext <m>e,t</m>. Students can type the messages into an online frequency analysis tool to get a frequency count, or, in a more programming-focused course, the collection of Python modules at <xref ref="inceResourcesFirstYearCollege2022"></xref> includes a module in which students write a frequency analysis tool themselves in Python.
			</p>

			<p>
				Students may notice one issue with this algorithm: what if you have no idea what ciphertext letter corresponds to plaintext <m>e</m> in your message? Certainly English messages may have different most-common letters. This could lead to a lesson on the index of coincidence and other probabilistic methods for determining both which cipher we’re dealing with and matching letter frequencies. Though these concepts are beyond the scope of these notes as written, see Chapter <m>2</m> of <xref ref="mcdevittClassNotesCryptologic2012"></xref> for an excellent treatment without prerequisites.
			</p>

<!-- div attr= class="act"-->
			<p>
				<term> 11</term>. 
			</p>

			<p><ol>
				<li>
							<p>
				<em>Encrypt some short (<m>3</m>-<m>10</m> words) plaintext using an affine cipher of your choice. Now, give students the equation of the affine cipher (say, <m>c\equiv 3p+2\mod26</m>) and have students determine the <em>decryption equation</em> for that affine cipher by solving for <m>p</m> in the cipher’s equation. Finally, use that decryption equation to determine the plaintext <m>p</m> corresponding to each given ciphertext letter <m>c</m>, and hence decrypt the message.</em>
			</p>
				</li>

				<li>
							<p>
				<em>Encrypt some short (<m>3</m>-<m>10</m> words) plaintext <em>in which the most common letter is <sq>e</sq> and the second-most common is <sq>t</sq>)</em> using an affine cipher of your choice. Now, have students use the algorithm to cryptanalyze this affine ciphertext.</em>
			</p>
				</li>

			</ol></p><!--</div attr= class="act">-->

			<p>
				At this point in the project, one may introduce the Vigenère cipher and its primary tools for cryptanalysis, the Kasiski and Friedman tests. This leads naturally to asking what happens when a Vigenère keyword is as long as the message it’s used to encrypt, whence students can prove to themselves that such a cipher (a <em>one-time pad</em>) is theoretically unbreakable by showing that different keywords lead to intelligible, but different, plaintext messages. The <em>Enigma machine</em> is then introduced as a <q>portable one-time pad generator,</q> providing an opportunity to tie the course to the more recent history of World War II.
			</p>

			<p>
				However, because these concepts are less explicitly connected to number theory and algebra, they are omitted in this text. See <xref ref="mcdevittClassNotesCryptologic2012"></xref> for an excellent set of notes for those who choose to teach this material.
			</p>

		</subsection>

	<section xml:id="extensions-and-alterations">
		<title>Extensions and Alterations</title>
		<introduction>
		<p>
			These resources are currently used at a small liberal arts college in an entire first-year seminar course entitled <q>Making &amp; Breaking Secret Codes.</q> As such, the project described above is supplemented with additional material and assignments such as the Python modules <xref ref="inceResourcesFirstYearCollege2022"></xref> and pre-class Reading Questions, often from <xref ref="singhCodeBookScience2011"></xref>.
		</p>

		<p>
			In this course, most of the material in <xref ref="mcdevittClassNotesCryptologic2012"></xref> (which is also provided to students as a supplementary resource) is discussed, with the possible exception of probability, which is often left out due to time constraints. A sample of the discussion of the Diffie-Hellman key exchange and modular exponentiation is provided in a Subsection <xref ref="the-diffie-hellman-key-exchange"/>. These notes lead into the material on the square-and-multiply algorithm, Euler’s Theorem, and eventually RSA encryption described in <xref ref="mcdevittClassNotesCryptologic2012"></xref>. Sometimes, the extended Euclidean algorithm is also introduced after describing the importance of finding multiplicative inverses when cryptanalyzing the affine cipher, though students without much prior mathematical experience tend to find this material confusing and somewhat intimidating.
		</p>

		<p>
			This activity has not yet been extended to a research project; however, some ideas for such projects are included in Subsection <xref ref="potential-undergraduate-research-projects" />.
		</p>

		<p>
			Finally, these notes arose from a course originally taught in the Duke TIP summer program which included an <q>evening session</q> in which students were walked through the Python modules found in <xref ref="inceResourcesFirstYearCollege2022"></xref>. It is highly recommended to guide students through these modules if they are used, since students without prior coding experience often find Python, especially its ubiquitous and sometimes uninformative syntax error messages, intimidating. The Python modules could also be used as the <q>backbone</q> for an independent study on the use of programming in cryptography and/or to introduce the material described above.
		</p>
	</introduction>

		<subsection xml:id="the-diffie-hellman-key-exchange">
			<title>The Diffie-Hellman key exchange</title>

			<p>
				In order to introduce more contemporary (i.e., post-<m>1970</m>) cryptography, specifically public-key cryptography, it is recommended to start with the Diffie-Hellman key exchange. The idea is introduced via discussion of the problem of informing the intended recipient what key to use to send an encrypted message (the <em>key distribution problem</em>), quite a significant issue: if one lives in a government where all Internet traffic is subject to government search, for example, how does one send a message across the world? Students often suggest physically transporting a key or sending a person to tell the recipient the key, but that just reframes the problem in terms of safely getting the key or person physically to the intended location.
			</p>

			<p>
				At this stage, students engage in a Socratic dialogue on whether it’s possible to solve the key distribution problem. In other words, suppose Alice wants to send a message to Bob, and suppose they live in a country in which any unencrypted message, or any key, will be intercepted and read by the postal service. For this discussion, imagine that Alice has a physical key that she wants to send to Bob in such a way that it can’t be opened by the postal service. How could Alice do this?
			</p>

			<p>
				One way that students eventually arrive at to solve this problem is that Alice can somehow secure the key so that it can’t be opened before Bob receives it. However, this begs the question of how <em>Bob</em> can access the key. Some semesters students discover the analogy used by Simon Singh in his excellent <em>Code Book</em> <xref ref="singhCodeBookScience2011"></xref>, which is usually assigned as a required text to provide students with historical background. Singh’s presentation is eminently readable without sacrificing accuracy or detail.
			</p>

			<p>
				In any case, the analogy works in the following steps:
			</p>

			<p><ol>
				<li>
							<p>
				Alice places her key inside a box and uses a padlock to lock the box. Alice keeps the key to the padlock and sends the locked box to Bob.
			</p>
				</li>

				<li>
							<p>
				The box can’t be opened in transit without Alice’s key. When Bob receives the box, he places an <em>additional</em> padlock on the box and keeps the key to his padlock. Bob then sends the doubly-locked box back to Alice.
			</p>
				</li>

				<li>
							<p>
				Again, the box can’t be opened in transit without both Alice and Bob’s keys. When Alice receives the box, she <em>unlocks</em> her padlock and sends the box back to Bob.
			</p>
				</li>

				<li>
							<p>
				Finally, the box can’t be unlocked in transit without Bob’s key. However, once Bob receives the box, he simply unlocks his padlock and opens the box.
			</p>
				</li>

			</ol></p>

			<p>
				This little story provides a solution to one of the oldest and most important problems in cryptography, the <em>key exchange problem</em>. Exchanging keys (whether physical or cryptographic) is a deeply vulnerable part of cryptography, and historically, if Alice and Bob wanted to exchange secret messages, they must first meet or somehow transmit a secret key <em>unencrypted</em>. Anyone who intercepts the key would be able to read any purportedly secret messages sent between Alice and Bob.
			</p>

			<p>
				Now, the astute reader may notice that the analogy above requires double-encryption with our given cipher to be commutative. Students then investigate which ciphers discussed so far actually have this property. This is a worthwhile pre-class activity to assign: is the shift cipher commutative? That is, if we want to encrypt a message with two consecutive shift ciphers, does it matter which order we use (it does not)? What about affine ciphers (it does)? Vigenère ciphers (it does not)? Other ciphers?
			</p>

			<p>
				What is really needed is a mathematical process that works more like padlocks than socks and shoes. In other words, we want to be able to have Alice and Bob each add their locks, then take them off in the opposite order in order to decrypt the message. And we want to do this without it being possible for anyone who intercepts the message to decrypt it! We want a <em>trapdoor one-way function</em> (easy to encrypt, hard to decrypt without the key) in which <em>encryption with two keys</em> is the same as decryption. A one-way function that arose in the affine cipher is multiplication mod <m>p</m> - finding inverses is hard!
			</p>

			<p>
				This stage is a perfect time to introduce modular exponentiation <em></em> and the theory behind it, which turns out to be the <q>lock</q> we use for the Diffie-Hellman key exchange. Though the treatment in these notes ends here, the treatment in <xref ref="mcdevittClassNotesCryptologic2012"></xref> is recommended for courses without prerequisites, or the instructor’s favorite number theory book for proof-based courses. These suggested materials also include the Extended Euclidean Algorithm, an introduction to Euler’s totient function, Fermat’s Little Theorem, Euler’s Theorem on the totient function, and proofs of all theorems involved appropriate in level for an introductory abstract algebra or number theory course.
			</p>

		</subsection>

		<subsection xml:id="potential-undergraduate-research-projects">
			<title>Potential undergraduate research projects</title>

			<p>
				The following are research projects that may be suitable for undergraduates who have a reasonable grasp on the material above and are interested in continuing to explore cryptography. In particular, these have been considered as research directions in a two-month summer undergraduate research program where the goal for students is primarily to gain mathematical maturity (defined here as gaining the ability to read research papers and to experience working on unsolved problems), not necessarily to prove publishable results.
			</p>

			<p><ol>
				<li>
							<p>
				Read <xref ref="smithMakingHashThings2015a"></xref>. Invent and test a new hash function. Perturb some conditions and see what happens.
			</p>
				</li>

				<li>
							<p>
				Read <xref ref="christensenPolishMathematiciansFinding2007a"></xref>. Perturb some conditions in Rejewski’s Theorems and see what happens.
			</p>
				</li>

				<li>
							<p>
				Read Problem <m>1727</m> in <xref ref="johnstonProblems2006"></xref> and its solution. Though this problem has already been solved, students could solve similar problems, perhaps by changing the seed or experimenting with determining the periods of the sequences generated from various seeds.
			</p>
				</li>

				<li>
							<p>
				Read <xref ref="marzuoliPostQuantumCryptography2011"></xref>. How could one break this cryptosystem? Investigate Shor’s algorithm and the ability of quantum computers to cryptanalyze RSA. How could Bob know how to mutate the knots without using RSA? Investigate alternate key exchange algorithms (besides public or private key encryption). Could one use a public knot whose inverse is hard to find and mimic RSA?
			</p>
				</li>

			</ol></p>

		</subsection>
	</section>

	<section xml:id="reflections-and-advice">
		<title>Reflections and Advice</title>

		<p>
			Learning about elementary ciphers has historically provided even first-year students with the motivation and context to gain experience and facility with modular arithmetic, including the idea of multiplicative inverses and the structure of finite cyclic groups. These ideas could easily lead to an examination of a broader range of group theory, for example in the context of an abstract algebra course, or become the first few weeks of a seminar course on the mathematics of code-making and code-breaking without prerequisites, as it has been implemented at the author’s institution. These notes are more than suitable for independent study or summer programs for motivated high-school students; in fact, this is how they first originated.
		</p>

		<p>
			It is very useful to undergird a discussion of this material with a very elementary introduction to Python programming, since all contemporary cryptography happens on computers and many more recent ciphers are incredibly cumbersome to implement by hand. The website CoCalc <xref ref="CoCalcCollaborativeCalculation"></xref>, by the makers of the SageMath computing software (which runs on top of Python), provides an online interface allowing students to program without installing any Python distributions on their own computers, saving headache. This website is not free, but each student is able to pay about $12 toward <q>upgrading</q> their CoCalc projects for one semester. The free version of CoCalc is almost unusable due to lag, so upgrading is recommended. The costs of such an upgrade can be implemented as course fees or more informally. The Python modules, as well as rubrics and solutions used to grade them, can be found at the author’s GitHub page <xref ref="inceResourcesFirstYearCollege2022"></xref>.
		</p>

		<p>
			The points of struggle mentioned above for students are worth reflecting on. These include multiple issues with learning to program for the first time: wading through confusing syntax errors, understanding the importance of whitespace in Python functions, and determining where to edit the preexisting code given to them. These issues can be somewhat ameliorated by walking through portions of Python modules as a whole class, breaking down the code underlying a function line by line to connect it to the more familiar steps of implementing a cipher by hand, and emphasizing that students are not expected to write their own code, only to change a word or two in the code provided for them. That said, students still tend to find Python, and programming, to be one of their least favorite aspects of what is generally a very fun course to teach and, per my students, to participate in. Other points of struggle include the extended Euclidean algorithm (due to the amount of symbolic manipulation involved), the complexity of the Enigma machine’s components, and more generally the concept of modular arithmetic (though students usually gain understanding quickly by way of the clock metaphor). Feedback is welcome on any of the material above. Cryptography is very fun, yet it provides a window for first-year students into material not usually taught until a first course in abstract algebra, as well as motivation for more experienced students to learn number theory.
		</p>

	</section>

	<section xml:id="additional-resources">
		<title>Additional Resources</title>

		<p>
			Please find the bibliography below. High praise is reserved for Tim McDevitt and Frank Arnold’s text <xref ref="mcdevittClassNotesCryptologic2012"></xref>, which is provided to the author’s students as a resource (and from which exercises are sometimes assigned as homework). Simon Singh’s <em>The Code Book</em> <xref ref="singhCodeBookScience2011"></xref> is an excellent, richly detailed, and deeply readable source for the historical and sociopolitical context of cryptography as well as entertaining descriptions of the underlying mathematics. The Cipher Challenge at the back of the book leads students through all of the ciphers described therein; the author uses it as a way for students to earn extra credit by solving a set number of the ten parts. In order to emphasize the human aspects of cryptography and its contemporary relevance, one may have students watch a video or read about the NSA/GCHQ and other cryptographic agencies as well as their recent political activities. Given that the NSA is the United States’ largest employer of Ph.D. mathematicians, and in the context of the revelations of Edward Snowden and other recent whistleblowers, this discussion remains deeply relevant.
		</p>

	<references>
		<biblio xml:id="bauerJamesSanbornKryptos2016">
			Bauer, C., Link, G., and Molle, D.
			(2016). 
			James Sanborn's Kryptos and the Matrix Encryption Conjecture.
			<em>Cryptologia, 40</em>(6), 541--552.
			<url href=" https://doi.org/10.1080/01611194.2016.1141556"/>
		</biblio>
		<biblio xml:id="brownSaintsScoundrelsTwo2015">
			Brown, E.
			(2015).
			Saints and Scoundrels and Two Theorems That Are Really the Same.
			<url href="http://maa.publisher.ingentaconnect.com/search/article?option1=fulltext\&amp;value1=cryptography\&amp;operator9=AND\&amp;option9=publications\&amp;value9=maa\&amp;freetype=unlimited\&amp;sortDescending=true\&amp;sortField=default\&amp;pageSize=10\&amp;index=14"/>
		</biblio>
		<biblio xml:id="christensenPolishMathematiciansFinding2007a">
			Christensen, C.
			(2007).
			Polish Mathematicians Finding Patterns in Enigma Messages.
			<em>Mathematics Magazine, 80</em>(4), 247--223.
		</biblio>
		<biblio xml:id="christensenReviewShadowFactory2009">
			Christensen, C.
			(2009).
			Review of <em>The Shadow Factory: The Ultra-Secret NSA from 9/11 to the Eavesdropping on America</em> by James Bamford.
			<em>Cryptologia, 33</em>(4), 356--358.
		</biblio>
		<biblio xml:id="CoCalcCollaborativeCalculation">
			CoCalc--Collaborative Calculation.
			<url href="https://cocalc.com"/>
		</biblio>
		<biblio xml:id="crismanNumberTheoryContext2021">
			Crisman, K.-D.
			(2021).
			<em>Number Theory: In Context and Interactive</em>.
		</biblio>
		<biblio xml:id="EnigmaSimulatorApps">
			Enigma Simulator -- Apps on Google Play.
			<url href="https://play.google.com/store/apps/details?id=uk.co.franklinheath.enigmasim\&amp;hl=en\&amp;gl=US"/>
		</biblio>
		<biblio xml:id="farhiQuantumMoneyKnots2010">
			Farhi, E., Gosset, D., Hassidim, A., Lutomirski, A., and Shor, P.
			(2010)
			Quantum Money from Knots.
			<em>arXiv:1004.5127</em>.
		</biblio>
		<biblio xml:id="friederesCryptii2022">
			Cryptii.
			(2022).
			<url href="https://github.com/cryptii/cryptii"/>
		</biblio>
		<biblio xml:id="horaciojimenezMininigmaEnigmaSimulator">
			Jiminez, H.
			Mininigma: Enigma Simulator.
			<url href="https://apps.apple.com/us/app/mininigma-enigma-simulator/id334855344"/>
		</biblio>
		<biblio xml:id="inceResourcesFirstYearCollege2022">
			Ince, K.
			(2022).
			Resources for a First-Year College Mathematical Cryptography Course.
			<url href="https://github.com/kaince/cryptography"/>
		</biblio>
		<biblio xml:id="johnstonProblems2006">
			Johnston, E.
			(2006).
			Problems.
			<em>Mathematics Magazine, 79</em>(4), 311.
		</biblio>
		<biblio xml:id="karstCryptographyContextCoteaching2019a">
			Karst, N. and Slegers, R.
			(2019).
			Cryptography in Context: Co-teaching Ethics and Mathematics.
			<em>PRIMUS 29</em>(9), 1039--1059.
		</biblio>
		<biblio xml:id="lastweektonightEncryptionLastWeek2016">
			Encryption: Last Week Tonight with John Oliver (HBO).
			(2016, March).
		</biblio>
		<biblio xml:id="marzuoliFaulttolerantMosaicEncoding2012">
			Marzuoli, A. and Palumbo, G.
			(2012).
			Fault-Tolerant Mosaic Encoding in Knot-Based Cryptography.
			<em>arXiv:1206.5709</em>
		</biblio>
		<biblio xml:id="marzuoliPostQuantumCryptography2011">
			Marzuoli, A. and Palumbo, G.
			(2011).
			Post Quantum Cryptography from Mutant Prime Knots.
			<em>International Journal of Geometric Methods in Modern Physics 8</em>(7), 1571--1581.
		</biblio>
		<biblio xml:id="mcdevittClassNotesCryptologic2012">
			McDevitt, T. and Arnold, F.
			(2012).
			Class Notes for Cryptologic Mathematics (FYS 100).
		</biblio>
		<biblio xml:id="reedsJOHNDEEMAGIC2006">
			Reeds, J.
			(2006).
			John Dee and the Magic Tables in the Book of SOYGA.
			In <em>John Dee: Interdisciplinary Studies in English Renaissance Thought</em>, ed. S. Clucas. 177--204.
		</biblio>
		<biblio xml:id="schaeferMathematicsEncryptionElementary2015">
			Schaefer, E.
			(2015).
			The Mathematics of Encryption: An Elementary Introduction.
			<url href="http://maa.publisher.ingentaconnect.com/search/article?option1=fulltext\&amp;value1=cryptography\&amp;operator9=AND\&amp;option9=publications\&amp;value9=maa\&amp;freetype=unlimited\&amp;sortDescending=true\&amp;sortField=default\&amp;pageSize=10\&amp;index=5"/>
		</biblio>
		<biblio xml:id="singhCodeBookScience2011">
			Singh, S.
			(2011).
			<em>The Code Book: The Science of Secrecy from Ancient Egypt to Quantum Cryptography</em>.
		</biblio>
		<biblio xml:id="smithMakingHashThings2015a">
			Smith, A. and Whitcher, U.
			(2015).
			Making a Hash of Things.
			<em>Math Horizons 23</em>(2), 5--8.
		</biblio>
	</references>

	</section>



</chapter>
